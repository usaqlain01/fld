<?php

/**
 * @file
 *
 * Custom code specific to this site.
 *
 * @copyright (C) Copyright 2009 Palantir.net
 * @license http://www.gnu.org/licenses/gpl-2.0.html
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Implements hook_menu().
 */
function customblog_menu() {
  
  $items['user/%user/blog'] = array(
    'title' => 'Blog',
    'page callback' => 'customblog_blog',
    'page arguments' => array(1),
    'access callback' => 'customblog_blog_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  
  return $items;
}

/**
 * Creates menu entry only if not tagged with Board of Trustees.
 */
function customblog_blog_access($user_viewed) {
  // Get user object and terms from field
  $user_wrapper = entity_metadata_wrapper('user', $user_viewed);
  $user_terms = $user_wrapper->field_dept_division_tags->value();
  
  // If tagged with Board of Trustees, do not create blog menu entry.
  foreach ($user_terms as $term) {
    if ($term->tid == '1261') {
      return FALSE;
    }
  }
  
  // If not tagged with Board of Trustees, create blog menu entry.
  return TRUE;
}

/**
 * Page callback for the user blog path.
 */
function customblog_blog($account) {
    // Add a link to the view feed.
    drupal_add_feed("user/{$account->uid}/blog/feed", t("Subscribe to Field Museum Blog - @username", array('@username' => format_username($account))));

    // Set the page title.
    drupal_set_title(t("@name's blog", array('@name' => format_username($account))), PASS_THROUGH);

    // Returns a blank page; we really just need the path so that blocks can be
    // placed here, etc.
    return array('#markup' => '');
  }

/**
 * Implements PathAuto's hook_pathauto().
 */
function customblog_pathauto($op) {
  if ($op == 'settings') {
    return (object) array(
      'module' => 'customblog',
      'token_type' => 'user',
      'groupheader' => t('Custom - User Blog Paths'),
      'patterndescr' => t('Pattern for user blogs'),
      'patterndefault' => 'users/[user:name]/blog',
      'bulkname' => t('Bulk update user blog paths'),
      'bulkdescr' => t('Generate aliases for all existing user blogs which do not already have aliases.'),
      'batch_update_callback' => 'customblog_pathauto_bulk_update_batch_process',
    );
  }
}

/**
 * Implements PathAuto's hook_path_alias_types().
 */
function customblog_path_alias_types() {
  $objects['user/%/blog'] = t('Custom - User Blog Paths');
  return $objects;
}

/**
 * Implements hook_user_insert().
 */
function customblog_user_insert(&$edit, $account, $category) {
  customblog_update_alias($account, 'insert');
}

/**
 * Implements hook_user_update().
 */
function customblog_user_update(&$edit, $account, $category) {
  customblog_update_alias($account, 'update');
}

/**
 * Implements hook_user_delete().
 */
function customblog_user_delete($account) {
  pathauto_path_delete_all("user/{$account->uid}/blog");
}

function customblog_update_alias(stdClass $account, $op, array $options = array()) {
  // Skip processing if the blog has no pattern.
  if (!pathauto_pattern_load_by_entity('customblog')) {
    return;
  }

  module_load_include('inc', 'pathauto');
  if (node_access('create', 'blog', $account)) {
    return pathauto_create_alias('customblog', $op, "user/{$account->uid}/blog", array('user' => $account));
  }
  else {
    pathauto_path_delete_all("user/{$account->uid}/blog");
    return;
  }
}

function customblog_update_alias_multiple(array $uids, $op, array $options = array()) {
  $options += array('message' => FALSE);

  $accounts = user_load_multiple($uids);
  $count = 0;
  foreach ($accounts as $account) {
    if (customblog_update_alias($account, $op, $options)) {
      $count++;
    }
  }

  if (!empty($options['message'])) {
    drupal_set_message(format_plural($count, 'Updated URL alias for 1 user blog.', 'Updated URL aliases for @count user blogs.'));
  }
}

function customblog_pathauto_bulk_update_batch_process(&$context) {
  if (!isset($context['sandbox']['current'])) {
    $context['sandbox']['count'] = 0;
    $context['sandbox']['current'] = 0;
  }

  $query = db_select('users', 'u');
  $concat = _pathauto_sql_concat("'user/'", 'u.uid', "'/blog'");
  $query->leftJoin('url_alias', 'ua', "$concat = ua.source");
  $query->addField('u', 'uid');
  $query->isNull('ua.source');
  $query->condition('u.uid', $context['sandbox']['current'], '>');
  $query->orderBy('u.uid');
  $query->addTag('pathauto_bulk_update');
  $query->addMetaData('entity', 'user');

  // Get the total number of items to process.
  if (!isset($context['sandbox']['total'])) {
    $context['sandbox']['total'] = $query->countQuery()->execute()->fetchField();

    // If there are no users to update, the stop immediately.
    if (!$context['sandbox']['total']) {
      $context['finished'] = 1;
      return;
    }
  }

  $query->range(0, 25);
  $uids = $query->execute()->fetchCol();

  customblog_update_alias_multiple($uids, 'bulkupdate');
  $context['sandbox']['count'] += count($uids);
  $context['sandbox']['current'] = max($uids);
  $context['message'] = t('Updated alias for user @uid.', array('@uid' => end($uids)));

  if ($context['sandbox']['count'] != $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['count'] / $context['sandbox']['total'];
  }
}
