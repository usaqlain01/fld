<?php

/**
 * @file
 *  Content moderation for Workbench.
 *
 * Based on $Id: content_moderation.module,v 1.12.2.17 2010/04/18 11:31:29 eugenmayer Exp $
 * @copyright (C) Copyright 2010 Palantir.net
 */

/**
 * Implements hook_menu().
 */
function workbench_moderation_menu() {
  $items = array();

  // Display a node's moderation history
  $items["node/%node/moderation"] = array(
    'title' => 'Moderate',
    'description' => 'Show the content moderation history.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'workbench_moderation_node_history_view',
    'page arguments' => array(1),
    'theme callback' => '_node_custom_theme',
    'access callback' => '_workbench_moderation_access',
    'access arguments' => array('view history', 1),
    'file' => 'workbench_moderation.node.inc'
  );

  // View the current revision of a node.
  $items["node/%node/current-revision"] = array(
    'page callback' => 'workbench_moderation_node_current_view',
    'page arguments' => array(1),
    'access callback' => '_workbench_moderation_access',
    'access arguments' => array('view revisions', 1),
    'file' => 'workbench_moderation.node.inc'
  );

  // Unpublishing a live revision.
  $items["node/%node/moderation/%/unpublish"] = array(
    'title' => 'Unpublish revision',
    'description' => 'Unpublish the current live revision.',
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workbench_moderation_node_unpublish_form', 1),
    'load arguments' => array(3),
    'theme callback' => '_node_custom_theme',
    'access arguments' => array('unpublish live version'),
    'file' => 'workbench_moderation.node.inc'
  );

  // Change the moderation state of a node.
  // @see workbench_moderation_get_moderation_links()
  $items["node/%node/moderation/%/change-state/%"] = array(
    'title' => 'Change Moderation State',
    'page callback' => 'workbench_moderation_moderate_callback',
    'page arguments' => array(1, 5),
    'load arguments' => array(3),
    'access callback' => '_workbench_moderation_moderate_access',
    'access arguments' => array(1, 5),
    'type' => MENU_CALLBACK,
  );

  // Module settings.
  $items["admin/config/workbench/moderation"] = array(
    'title' => 'Workbench Moderation',
    'description' => 'Configure content moderation.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workbench_moderation_admin_settings_states'),
    'access arguments' => array('administer workbench moderation'),
    'file' => 'workbench_moderation.admin.inc',
  );
  $items['admin/config/workbench/moderation/general'] = array(
    'title' => 'States',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/config/workbench/moderation/transitions'] = array(
    'title' => 'Transitions',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workbench_moderation_admin_settings_transitions'),
    'access arguments' => array('administer workbench moderation'),
    'file' => 'workbench_moderation.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function workbench_moderation_menu_alter(&$items) {
  // Hijack the node/X/edit page to ensure that the right revision (most current)
  // is displayed.
  $items['node/%node/edit']['page callback'] = 'workbench_moderation_node_edit_page_override';
  $items['node/%node/revisions']['access callback'] = 'workbench_moderation_revision_access';
}

/**
 * Deny access for items we override.
 *
 * If moderation is in use, then the Revisions tab is not used, so we remove access to it.
 *
 * @see _node_revision_access()
 *
 * @param $node
 *   The node being acted upon.
 * @param $op
 *   The operation being requested.
 *
 * @return
 *   Boolean TRUE or FALSE.
 */
function workbench_moderation_revision_access($node, $op = 'view') {
  if (workbench_moderation_node_type_moderated($node->type) === FALSE) {
    return _node_revision_access($node, $op);
  }
  return FALSE;
}

/**
 * Implements hook_permission().
 *
 * Provides permissions for each state to state change
 */
function workbench_moderation_permission() {
  $permissions = array();
  $permissions['administer workbench moderation'] = array(
    'title' => t('Administer Workbench Moderation'),
  );
  $permissions['bypass workbench moderation'] = array(
    'title' => t('Bypass moderation restrictions'),
    'restrict access' => TRUE,
  );
  $permissions['view moderation history'] = array(
    'title' => t('View moderation history'),
  );
  $permissions['view moderation messages'] = array(
    'title' => t('View the moderation messages on a node')
  );
  $permissions['unpublish live version'] = array(
    'title' => t('Unpublish the current live version'),
  );
  $permissions['use workbench_moderation my drafts tab'] = array(
    'title' => t('Use "My Drafts" workbench tab')
  );
  $permissions['use workbench_moderation needs review tab'] = array(
    'title' => t('Use "Needs Review" workbench tab')
  );

  // @see workbench_moderation_state_allowed()
  // Per-node-type, per-transition permissions.
  $node_types = workbench_moderation_moderate_node_types();
  $transitions = workbench_moderation_transitions_get();
  foreach ($transitions as $from_state => $states) {
    $from_state = check_plain($from_state);
    foreach ($states as $to_state) {
      $to_state = check_plain($to_state);
      // Always set a permission to perform all moderation states.
      $permissions["moderate content from $from_state to $to_state"] = array(
        'title' => t('Moderate all content from !from_state to !to_state', array('!from_state' => $from_state, '!to_state' => $to_state)),
      );
      // Per-node type permissions are very complex, and should only be used if
      // absolutely needed. For right now, this is hardcoded to OFF. To enable it,
      // Add this line to settings.php and then reset permissions.
      //   $conf['workbench_moderation_per_node_type'] = TRUE;
      if (variable_get('workbench_moderation_per_node_type', FALSE)) {
        foreach ($node_types as $node_type) {
          $permissions["moderate $node_type state from $from_state to $to_state"] = array(
            'title' => t('Moderate @node_type state from !from_state to !to_state', array('@node_type' => node_type_get_name($node_type), '!from_state' => $from_state, '!to_state' => $to_state)),
          );
        }
      }
    }
  }
  return $permissions;
}

/**
 * Custom access handler for node operations.
 *
 * @param $op
 *   The operation being requested.
 * @param $node
 *   The node being acted upon.
 *
 * @return
 *   Boolean TRUE or FALSE.
 */
function _workbench_moderation_access($op, $node) {
  // The user must be able to view the moderation history.
  $access = user_access("view moderation history");

  // If we do not control this node type, deny access.
  if (workbench_moderation_node_type_moderated($node->type) === FALSE) {
    $access = FALSE;
  }
  // If the user cannot edit this node, deny access.
  if (!node_access('update', $node)) {
    $access = FALSE;
  }
  // If the user cannot view the moderation history, deny access.
  if (!user_access('view moderation history')) {
    $access = FALSE;
  }

  // Allow other modules to change our rule set.
  drupal_alter('workbench_moderation_access', $access, $op, $node);

  return $access;
}

/**
 * Implements hook_help().
 */
function workbench_moderation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#workbench_moderation':
      return '<p>' . t("Enables you to control node display with a moderation
        workflow. You can have a 'Live version' for all visitors and pending
        revisions which need to be approved to become the new 'Live Version.'") . '</p>';
  }
}

/**
 * Implements hook_views_api().
 */
function workbench_moderation_views_api() {
  return array('api' => 2.0);
}

/**
 * Implements hook_node_presave().
 *
 * Ensure that a node in moderation has the proper publication status.
 * We set $node->status = 0 (unpublished) if this is a new node which has not
 * been marked as published, or if the node has no published version.
 */
function workbench_moderation_node_presave($node) {
  global $user;
  // Set the published status when a node is set to live
  // Is this a node that is controlled by content moderation?
  if (isset($node->workbench_moderation_state_new)) {
    // Is the new state live or is there an existing published version?
    if ($node->workbench_moderation_state_new == workbench_moderation_state_published() ||
       !empty($node->workbench_moderation['published']->nid)) {
      $node->status = 1;
    }
    else {
      $node->status = 0;
    }
  }
}


/**
 * Implements hook_node_insert().
 *
 * Wrapper call to the update hook.
 */
function workbench_moderation_node_insert($node) {
  workbench_moderation_node_update($node);
}


/**
 * Implements hook_node_update().
 *
 * Handles the submit of the node form moderation information
 */
function workbench_moderation_node_update($node) {
  global $user;
  // Don't proceed if moderation is not enabled on this content type, or if we're replacing an
  // already-published version.
  if (!workbench_moderation_node_type_moderated($node->type) ||
      !empty($node->workbench_moderation['updating_live_revision'])) {
    return;
  }

  // Set default moderation state values.
  if (!isset($node->workbench_moderation_state_current)) {
    $node->workbench_moderation_state_current = ($node->status ? workbench_moderation_state_published() : workbench_moderation_state_none());
  };
  if (!isset($node->workbench_moderation_state_new)) {
    $node->workbench_moderation_state_new = variable_get('workbench_moderation_default_state_' . $node->type);
  };

  // If this is a new node, give it some information about 'my revision'.
  if (!isset($node->workbench_moderation)) {
    $node->workbench_moderation = array();
    $node->workbench_moderation['my_revision'] = $node->workbench_moderation['current'] = (object) array(
      'from_state' => workbench_moderation_state_none(),
      'state' => workbench_moderation_state_none(),
      'nid' => $node->nid,
      'vid' => $node->vid,
      'uid' => $user->uid,
      'current' => TRUE,
      'published' => FALSE,
      'stamp' => $node->changed,
    );
  }

  // Apply moderation changes if this is a new revision or if the moderation state has changed.
  if ($node->revision || $node->workbench_moderation_state_current != $node->workbench_moderation_state_new) {
    workbench_moderation_moderate($node, $node->workbench_moderation_state_new);
  }

  // Tell the user what is happening to their content if the revision isn't published.
  if (!$node->status) {
    drupal_set_message(t('Your content is now awaiting moderation.'), 'status', FALSE);
  }

  return;
}

/**
 * Implements hook_node_load().
 *
 * Load moderation history and status on a node.
 */
function workbench_moderation_node_load($nodes) {
  foreach ($nodes as $node) {
    // Add the node history
    workbench_moderation_node_data($node);
  }
}

/**
 * Implements hook_node_view().
 *
 * Ensures that the proper version of a ode is displayed.
 */
function workbench_moderation_node_view($node, $view_mode = 'full') {
  // Is this a moderated content type?
  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  // Is this the live version of this node?
  if ($live_node = workbench_moderation_node_live_load($node)) {
    $has_revision = FALSE;
    $status = 'status';
    if ($live_node->vid != $node->vid) {
      $has_revision = TRUE;
      $status = 'warning';
    }
    $node = $live_node;
    // Alert the user that there are moderated versions
    // Only show this message on node/x
    if (arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == NULL) {
      // Only show the message once and if there are subsequent revisions of
      // this content
      static $live_control = FALSE;
      if (!$live_control && $has_revision && user_access('view content moderation message')) {
        $message = t('This is the live version of this !type.', array('!type' => $node->type));
        $message .= ' ' . t('View the most recent version in moderation !here.', array('!here' => l(t('here'), 'node/' . $node->nid . '/current-revision')));
        drupal_set_message($message, $status, FALSE);
        $live_control = TRUE;
      }
    }
    return;
  }

  // This node is in moderation. If the user has permission to see unpublished
  // nodes, show it and alert the user
  $node = workbench_moderation_node_current_load($node);
  if (arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == NULL) {
    static $revision_control = FALSE;
    if (! $revision_control) {
      drupal_set_message(t('The content of this document has not been approved yet.'), 'warning', FALSE);
      $revision_control = TRUE;
    }
  }
}
/* THIS IS ALL OLDER CODE that needs revision or removal from hook_node_view().

  // If we are showing a revision, show the author informations
  if (($live != NULL && $node->vid != $live->vid) && user_access('view content moderation message')) {
    // Get username for the revision rather than the original node.
    $revision_author = user_load_multiple($node->revision_uid);
    drupal_set_message(t('The revision of this node has been created on @date by !author.', array('@date' => format_date($node->revision_timestamp, 'short'), '!author' => theme('username', array('account' => $revision_author)))), 'status', FALSE);
  }
  // If we are showing the live revision of the node and there are any pending version. tell the user about that
  elseif (user_access('view content moderation message')) {
    $pending_revisions = _workbench_moderation_get_latest_revisions($node->nid, 0, NULL);
    $count = count($pending_revisions);

    if ($count == 1) {
      drupal_set_message(t('This document has 1 pending revision', array('@count' => $count)), 'status', FALSE);
    }
    elseif ($count > 1) {
      drupal_set_message(t('This document has @count pending revisions', array('@count' => $count)), 'status', FALSE);
    }
  }
  */

/**
 * Implements hook_node_delete().
 */
function workbench_moderation_node_delete($node) {
  // Delete node history when it is deleted.
  db_delete('workbench_moderation_node_history')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add moderation rules to node types.
 */
function workbench_moderation_form_node_type_form_alter(&$form, $form_state) {
  // Add JS which handles hiding and showing of these options.
  $form['#attached']['js'][] = drupal_get_path('module', 'workbench_moderation') . '/js/workbench_moderation.js';
  // What states can this node start out in?
  $form['workflow']['node_options']['#options']['moderation'] = t('Enable moderation of revisions');
  $form['workflow']['node_options']['#description'] .= '<p>' . t('Revisions must be enabled for moderation');
  $form['workflow']['workbench_moderation_default_state'] = array(
    '#title' => t('Default moderation state'),
    '#type' => 'select',
    '#options' => workbench_moderation_states_get(),
    '#default_value' => variable_get('workbench_moderation_default_state_' . $form['#node_type']->type),
    '#description' => t('Set the default workflow state for this content.
      If a user has additional moderation rights they will be able to change it
      on the node')
  );
  $form['#validate'][] = 'workbench_moderation_node_type_form_validate';
}

/**
 * Validate the content type form.
 */
function workbench_moderation_node_type_form_validate($from, &$form_state) {
  // Ensure that revisions are enabled if moderation is.
  if ($form_state['values']['node_options']['moderation']) {
    $form_state['values']['node_options']['status'] = 0;
    $form_state['values']['node_options']['revision'] = 1;
  }
}

/**
 * Implements hook_form_alter().
 *
 * Forcing new reversion and publishing.
 *
 * @TODO: Use the node_forms alter instead?
 */
function workbench_moderation_form_alter(&$form, $form_state, $form_id) {
  global $user;

  // This must be a node form and a type that has moderation enabled
  if (!(isset($form['#node_edit_form']) && workbench_moderation_node_type_moderated($form['type']['#value']))) {
    return;
  }
  // Set a moderation state even if there is not one defined
  if (isset($form['#node']->workbench_moderation['current']->state)) {
    $moderation_state = $form['#node']->workbench_moderation['current']->state;
  }
  else {
    $moderation_state = variable_get('workbench_moderation_default_state_' . $form['type']['#value']);
  }

  // Store the current moderation state
  $form['workbench_moderation_state_current'] = array(
    '#type' => 'value',
    '#value' => $moderation_state
  );
  // We have a use case where a live node is being edited. This will always
  // revert back to the original node status.
  if ($moderation_state == workbench_moderation_state_published()) {
    $moderation_state = workbench_moderation_state_none();
    drupal_set_message(t('%title is currently published to the site. If you edit this page, the new revision must undergo moderation before your changes go live.', array('%title' => $form['#node']->title)), 'warning', FALSE);
  }
  // Get all the states *this* user can access. If states is false, this user
  // can not change the moderation state
  if ($states = workbench_moderation_states_next($moderation_state, $user, $form['type']['#value'])) {
    $current = array($moderation_state => t('Current: !state', array('!state' => $moderation_state)));
    $states = array_merge($current, $states);
    $form['options']['workbench_moderation_state_new'] = array(
      '#title' => t('Moderation state'),
      '#type' => 'select',
      '#options' => $states,
      '#default_value' => $moderation_state,
      '#description' => t('Set the moderation state for this content.'),
      '#access' => $states ? TRUE: FALSE,
    );
  }
  else {
    // Store the current moderation state
    $form['workbench_moderation_state_new'] = array(
      '#type' => 'value',
      '#value' => $moderation_state
    );
  }
  // Move the Revision log under publishing to make things pretty
  $form['options']['log'] = $form['revision_information']['log'];
  $form['options']['log']['#title'] = t('Moderation notes');
  $action = !empty($form['#node']->nid) ? t('Edited') : t('Created');
  $form['options']['log']['#default_value'] = t('!action by @user.', array('!action' => $action, '@user' => $user->name));
  unset($form['revision_information']['log']);

  // Always create new revisions for nodes that are moderated
  $form['revision_information']['revision']['#default_value'] = TRUE;
  // Do not allow users to change the revision status
  $form['revision_information']['#access'] = FALSE;

  // User has no ability to choose if this content is published or not. If the
  // moderation status is live, then it will be published, otherwise not.
  $form['options']['status']['#access'] = FALSE;
}

/**
 * Overrides the node/X/edit page to ensure the proper revision is shown.
 *
 * @param $node
 *   The node being acted upon.
 * @return
 *   A node editing form.
 */
function workbench_moderation_node_edit_page_override($node) {
  // Check to see if this is an existing node
  if (isset($node->nid)) {
    if (workbench_moderation_node_type_moderated($node->type)) {
      // Load the node moderation data
      workbench_moderation_node_data($node);
      // We ONLY edit the current revision
      $node = workbench_moderation_node_current_load($node);
      // Is this revision the same as the live revision?
      if (!isset($node->workbench_moderation['published']->vid) || $node->vid != $node->workbench_moderation['published']->vid) {
        // This revision is not live; alert the user
        if (!user_access('bypass workbench moderation')) {
          drupal_set_message(t('You are editing the pending revision (@revision)
            and not the live version of this content. Your changes will be
            moderated before they are reflected.',
            array(
              '@revision' => $node->vid
              )
            ), 'warning', FALSE
          );
        }
      }
    }
  }
  // Ensure we have the editing code.
  module_load_include('inc', 'node', 'node.pages');
  return node_page_edit($node);
}

/**
 * Returns the key which represents the live version.
 * Should be later an interface to change the live state
 */
function workbench_moderation_state_published() {
  return t('Publish');
}

/**
 * Returns the key which represents the neutral non moderated version.
 * Should be later an interface to change the live state
 */
function workbench_moderation_state_none() {
  return t('Draft');
}

/**
 * Determine if this content type is set to be moderated
 *
 * @param $type
 *   String, content type name
 * @return boolean
 */
function workbench_moderation_node_type_moderated($type) {
  // Is this content even in moderatation?
  $options = variable_get("node_options_$type", array());
  if (in_array('revision', $options) && in_array('moderation', $options)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * List of content types that are moderated
 */
function workbench_moderation_moderate_node_types() {
  $types = node_type_get_types();
  $result = array();
  foreach ($types as $type) {
    // Is this content even in moderatation?
    if (workbench_moderation_node_type_moderated($type->type)) {
      $result[] = $type->type;
    }
  }
  return $result;
}

/**
 * Check whether a user may change the state of a node.
 *
 * This check is based on transition and node type. Users
 * with the 'bypass workbench moderation' permission may make any state transition.
 * @see workbench_moderation_permission()
 *
 * Note that we do not use content-type specific moderation by default. To
 * enable that, see the instructions in workbench_moderation_permission().
 *
 * @param $account
 *   The user account being checked.
 * @param $from_state
 *   The original moderation state.
 * @param $to_state
 *   The new moderation state.
 *
 * @return
 *   Bollean TRUE or FALSE.
 */
function workbench_moderation_state_allowed($account, $from_state, $to_state, $node_type) {
  // Allow super-users to moderate all content.
  if (user_access("bypass workbench moderation", $account)) {
    return TRUE;
  }

  // Can this user moderate all content for this transition?
  if (user_access("moderate content from $from_state to $to_state", $account)) {
    return TRUE;
  }

  // Are we using complex node type rules for this transition?
  if (variable_get('workbench_moderation_per_node_type', FALSE) && user_access("moderate $node_type state from $from_state to $to_state", $account)) {
    return TRUE;
  }

  // Default return.
  return FALSE;
}

/**
 * Adds current and live revision data to a node.
 *
 * @param $node
 *   The node being acted upon.
 */
function workbench_moderation_node_data($node) {
  // Make sure that this node type is moderated.
  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  // Path module is stupid and doesn't load its data in node_load.
  if (module_exists('path') && isset($node->nid)) {
    $path = array();
    $conditions = array('source' => 'node/' . $node->nid);
    if ($node->language != LANGUAGE_NONE) {
      $conditions['language'] = $node->language;
    }
    $path = path_load($conditions);
    if ($path === FALSE) {
      $path = array();
    }
    if (isset($node->path)) {
      $path += $node->path;
    }
    $path += array(
      'pid' => NULL,
      'source' => 'node/' . $node->nid,
      'alias' => '',
      'language' => isset($node->language) ? $node->language : LANGUAGE_NONE,
    );
  
    $node->path = $path;
  }

  // Build a default 'current' moderation record. Nodes will lack a workbench_moderation record if
  // moderation was not enabled for their node type when they were created. In that case, assume the
  // live node is at the current revision.
  $defaults = array(
    'hid' => NULL,
    'nid' => $node->nid,
    'vid' => $node->vid,
    'from_state' => workbench_moderation_state_none(),
    'state' => ($node->status ? workbench_moderation_state_published() : workbench_moderation_state_none()),
    'uid' => $node->uid,
    'stamp' => $node->changed,
    'published' => $node->status,
    'current' => 1,
  );

  // We'll store moderation state information in an array on the node.
  $node->workbench_moderation = array();

  // Fetch the most recent revision from the {node_revision} table. This is the current revision
  // ("head").
  $query = db_select('node_revision', 'r');
  $query->addJoin('LEFT OUTER', 'workbench_moderation_node_history', 'm', 'r.vid = %alias.vid');
  $query->condition('r.nid', $node->nid)
    ->orderBy('r.vid', 'DESC')
    ->orderBy('m.hid', 'DESC')
    ->fields('m')
    ->fields('r', array('title', 'timestamp'));
  $current = $query->execute()->fetchObject();

  if (!$current) {
    $current = (object) $defaults;
  }
  else {
    // Fill in any defaults that are missing from the database record. We need to maintain false-y
    // values except for NULL, so array_filter() + array_merge() wouldn't work here.
    foreach (array_keys($defaults) as $key) {
      if (is_null($current->$key)) {
        $current->$key = $defaults[$key];
      }
    }
  }

  $node->workbench_moderation['current'] = $current;

  // Fetch the published revision. There may not be a workbench_moderation record for some nodes,
  // but in those cases if the node is published, $current->published will be TRUE.
  if ($current->published) {
    $published = $current;
  }
  else {
    // Fetch the most recent published revision.
    $query = db_select('node', 'n');
    $query->addJoin('INNER', 'node_revision', 'r', 'n.vid = r.vid');
    $query->addJoin('LEFT OUTER', 'workbench_moderation_node_history', 'm', 'r.vid = m.vid');
    $query->condition('n.nid', $node->nid)
      ->condition('n.status', 1)
      ->orderBy('m.hid', 'DESC')
      ->fields('r', array('nid', 'vid', 'title', 'timestamp'))
      ->fields('m');
    $published = $query->execute()->fetchObject();
  }
  // If we have a published copy, add that to the array.
  if ($published) {
    $published->state = workbench_moderation_state_published();
    $node->workbench_moderation['published'] = $published;
  }

  // Fetch the workbench_moderation record for this node object's revision. If it is either the
  // current or published version of the node, that data will be used.
  if ($node->vid == $current->vid) {
    $my_revision = $current;
  }
  elseif ($published && $node->vid == $published->vid) {
    $my_revision = $published;
  }
  else {
    $query = db_select('node_revision', 'r');
    $query->addJoin('LEFT OUTER', 'workbench_moderation_node_history', 'm', 'r.vid = m.vid');
    $query->condition('m.vid', $node->vid)
      ->orderBy('m.hid', 'DESC')
      ->fields('m')
      ->fields('r', array('nid', 'vid', 'title', 'timestamp'));
    $my_revision = $query->execute()->fetchObject();

    // This might happen if you're turning workbench_moderation on and off, but it should be really
    // rare. Workbench_moderation must have recorded a current version, and then the node table must
    // contain a different and unpublished version.
    if (!$my_revision) {
      $my_revision = (object) array(
        'hid' => NULL,
        'nid' => $node->nid,
        'vid' => $node->vid,
        'from_state' => workbench_moderation_state_none(),
        'state' => workbench_moderation_state_none(),
        'uid' => $node->uid,
        'stamp' => $node->changed,
        'published' => 0,
        'current' => 0,
      );
    }
  }
  // Add my revision to the array.
  $node->workbench_moderation['my_revision'] = $my_revision;
}

/**
 * Utility function to load the current version of a node.
 *
 * This is used to load the current moderated version of a node not the live version.
 * This is needed because the live version of a node will have the
 *
 * @param $node
 *   The node being acted upon.
 *
 * @return
 *   The current node according to moderation.
 */
function workbench_moderation_node_current_load($node) {
  // Is there a current revision?
  if (isset($node->workbench_moderation['current']->vid)) {
    // Ensure that we will return the current version
    if ($node->vid != $node->workbench_moderation['current']->vid) {
      $node = node_load($node->nid, $node->workbench_moderation['current']->vid);
    }
  }
  return $node;
}


/**
 * Utility function to load the live version of a node.
 *
 * This is encapsulated so that changes to how the moderation data is stored
 * will not impact the API.
 *
 * @param $node
 *   The node being acted upon.
 *
 * @return
 *   The node object of the live revision.
 */
function workbench_moderation_node_live_load($node) {
  // Is there a live revision of this node?
  if (isset($node->workbench_moderation['published']->vid)) {
    // If the live revision is not this version, we need to load that revision
    if ($node->vid != $node->workbench_moderation['published']->vid) {
      return node_load($node->nid, $node->workbench_moderation['published']->vid, TRUE);
    }
    // This is the live node, return it
    return $node;
  }
}


/**
 * Utility function to determine if this node is in the live state
 *
 * @param $node
 *   The node being acted upon.
 *
 * @return
 *   Boolean TRUE if this is the current revision. FALSE if not.
 */
function workbench_moderation_node_is_current($node) {
  if (isset($node->workbench_moderation['published']->vid) && isset($node->workbench_moderation['current']->vid)) {
    if ($node->workbench_moderation['published']->vid == $node->workbench_moderation['current']->vid) {
      return TRUE;
    }
    return FALSE;
  }
  // If not set, then TRUE.
  return TRUE;
}

/**
 * Return an array of transitions.
 *
 * @return
 *   An associative array where rhe key is the 'from' state and the value
 *   is an array of possible 'to' states.
 */
function workbench_moderation_transitions_get() {
  $transitions = array();

  $query = db_select('workbench_moderation_transitions', 't');
  $alias_from = $query->addJoin('INNER', 'workbench_moderation_states', NULL, 't.from_name = %alias.name');
  $alias_to = $query->addJoin('INNER', 'workbench_moderation_states', NULL, 't.to_name = %alias.name');
  $result = $query->fields('t', array('from_name', 'to_name'))
    ->orderBy("$alias_from.weight", 'ASC')
    ->orderBy("$alias_to.weight", 'ASC')
    ->execute();

  while ($t = $result->fetchObject()) {
    $transitions[$t->from_name][] = $t->to_name;
  }

 return $transitions;
}

/**
 * Return a list of all states in the system.
 *
 * @return
 *   An associative array in the format $state[NAME OF STATE] => DESCRIPTION.
 */
function workbench_moderation_states_get() {
  static $states = FALSE;
  if (!$states) {
    $results = db_query('SELECT * FROM {workbench_moderation_states} ORDER BY weight ASC');
    $states = array();
    foreach ($results as $state) {
      $states[$state->name] = $state->description ? $state->description : $state->name;
    }
  }
  return $states;
}

/**
 * Provides a list of possible next states for this node.
 *
 * This function is used in permissions checks, so this should not ever return
 * un-permission-checked transitions.
 *
 * @param $current_state
 *   The current moderation state.
 * @param $account
 *   The user object being checked.
 * @param $node_type
 *   The node type being acted upon.
 *
 * @return
 *   If the user may moderate a change, return an array of possible state changes.
 *   Otherwise, return FALSE.
 */
function workbench_moderation_states_next($current_state, $account, $node_type) {
  // Make sure we have a current state.
  if (!$current_state) {
    $current_state = workbench_moderation_state_none();
  }

  if (!$account) {
    $account = $user;
  }

  if (user_access('bypass workbench moderation', $account)) {
    // Some functions expect an array of $state => $state pairs.
    $states = array_keys(workbench_moderation_states_get());
    return array_combine($states, $states);
  }
  else {
    // Get a list of possible transitions.
    $states = db_select('workbench_moderation_transitions', 'transitions')
      ->condition('transitions.from_name', $current_state)
      ->condition('transitions.ntype', array($node_type, 'all'))
      ->fields('transitions', array('to_name'))
      ->execute()
      ->fetchAllKeyed(0, 0);

    // Check whether the user has permission to make each transition. The 'bypass workbench
    // moderation' permission is accounted for in workbench_moderation_state_allowed().
    if ($states) {
      foreach ($states as $state) {
        if (!workbench_moderation_state_allowed($account, $current_state, $state, $node_type)) {
          unset($states[$state]);
        }
      }
      return $states;
    }
  }

  return FALSE;
}

/**
 * Menu access callback to check whether a user may make a particular transition on a node.
 *
 * @param $node
 *   The node being acted upon.
 * @param $state
 *   The new moderation state.
 *
 * @return
 *   Booelan TRUE or FALSE.
 */
function _workbench_moderation_moderate_access($node, $state) {
  global $user;

  $my_revision = $node->workbench_moderation['my_revision'];
  $next = workbench_moderation_states_next($my_revision->state, $user, $node->type);
  return node_access('update', $node, $user)   // the user can edit the node
          && $my_revision->current                   // this is the current revision (no branching the revision history)
          && ($next_states = $next)                  // there are next states the user may transition to
          && isset($next_states[$state]);           // this state is in the available next states
}

/**
 * Provide quick moderation of nodes.
 *
 * Access is controlled by the menu router to these pseudo-form callbacks.
 * This function is also abstracted so that it can be called from any node context.
 *
 * @see _workbench_moderation_moderate_access()
 * @see workbench_moderation_menu()
 * @see workbench_moderation_node_update()
 *
 * @param $node
 *   The node being acted upon.
 * @param $state
 *   The new moderation state requested.
 */
function workbench_moderation_moderate($node, $state) {
  global $user;

  $old_revision = $node->workbench_moderation['my_revision'];

  // Build a history record.
  $new_revision = (object) array(
    'from_state' => $old_revision->state,
    'state' => $state,
    'nid' => $node->nid,
    'vid' => $node->vid,
    'uid' => $user->uid,
    'current' => ($old_revision->vid == $node->workbench_moderation['current']->vid),
    'published' => ($state == workbench_moderation_state_published()),
    'stamp' => $_SERVER['REQUEST_TIME'],
  );

  // If this is the new 'current' moderation record, it should be the only one flagged 'current' in
  // {workbench_moderation_node_history}.
  if ($new_revision->current) {
    $query = db_update('workbench_moderation_node_history')
      ->condition('nid', $node->nid)
      ->fields(array('current' => 0))
      ->execute();
  }

  // If this revision is to be published, the new moderation record should be the only one flagged
  // 'published' in {workbench_moderation_node_history}.
  if ($new_revision->published) {
    $query = db_update('workbench_moderation_node_history')
      ->condition('nid', $node->nid)
      ->fields(array('published' => 0))
      ->execute();
  }

  // Save the node history record.
  drupal_write_record('workbench_moderation_node_history', $new_revision);

  // Update the node's content_moderation information so that we can publish it if necessary.
  $node->workbench_moderation['my_revision'] = $new_revision;
  if ($new_revision->current) {
    $node->workbench_moderation['current'] = $new_revision;
  }
  if ($new_revision->published) {
    $node->workbench_moderation['published'] = $new_revision;
  }

  // If we're moderating an unpublished version and there is an existing published version, make
  // sure that the published version is live.
  if (!empty($node->workbench_moderation['published']) && empty($node->is_new)) {
    drupal_register_shutdown_function('workbench_moderation_store');
    workbench_moderation_set_node($node);
  }
}

/**
  * Stores a node for saving with the shutdown callback.
  *
  * @param $node
  *   The node to be saved, or NULL to return the node.
  *
  * @return
  *   The node object, if requested.
  */
function workbench_moderation_set_node($node = NULL) {
  static $value;
  if (is_null($node)) {
    return $value;
  }
  $value = $node;
}

/**
 * Get the node from workbench_moderation_set_node().
 *
 * @return
 *   A node to be revised and saved.
 */
function workbench_moderation_get_node() {
  return workbench_moderation_set_node();
}

/**
 * Shutdown callback for saving a node revision.
 *
 * This function is called by drupal_register_shutdown_function().
 * The purpose is to delay a node_save() call so that a live revision
 * is not called during hook_node_update().
 *
 * Instead, we delay the update until the new revision is saved. This way,
 * we can more safely call the revision and pick up changes to items
 * that are not revisioned (such as menu and path assignments).
 *
 * @see workbench_moderation_moderate()
 * @see workbench_moderation_set_node()
 */
function workbench_moderation_store() {
  if ($node = workbench_moderation_get_node()) {
    watchdog('Workbench moderation', 'Saved node revision: %node as live version for node %live.', array('%node' => $node->vid, '%live' => $node->nid), WATCHDOG_NOTICE, l($node->title, 'node/'. $node->nid));
    $live_revision = workbench_moderation_node_live_load($node);
    // Make sure we're published.
    $live_revision->status = 1;
    // Don't create a new revision.
    $live_revision->revision = 0;
    // Prevent another moderation record from being written.
    $live_revision->workbench_moderation['updating_live_revision'] = TRUE;

    // Reset flag from taxonomy_field_update() so that {taxonomy_index} values aren't written twice.
    $taxonomy_index_flag = &drupal_static('taxonomy_field_update', array());
    unset($taxonomy_index_flag[$node->nid]);

    // @TODO: do we trust node_save() here?
    node_save($live_revision);
  }
}

/**
 * Helper function to redirect after a state change submission.
 *
 * @param $node
 *   The node being acted upon.
 * @param $state
 *   The new moderation state requested.
 */
function workbench_moderation_moderate_callback($node, $state) {
  workbench_moderation_moderate($node, $state);
  drupal_goto(isset($_GET['destination']) ? $_GET['destination'] : 'node/' . $node->nid . '/moderation');
}

/**
 * Generate a list of links to available moderation actions.
 *
 * @param $node
 *   The node being acted upon.
 * @param $url_options
 *   An array of options to pass, following the url() function syntax.
 *
 * @return
 *   A list of links to display with the revision.
 */
function workbench_moderation_get_moderation_links($node, $url_options = array()) {
  global $user;

  // Make sure that this node type is moderated.
  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  // Build links to available moderation states.
  $links = array();
  $my_revision = $node->workbench_moderation['my_revision'];
  if ($my_revision->vid == $node->workbench_moderation['current']->vid
      && $next_states = workbench_moderation_states_next($my_revision->state, $user, $node->type)) {
    foreach ($next_states as $state => $label) {
      $links[] = array_merge($url_options, array(
        'title' => $state,
        'href' => "node/{$node->nid}/moderation/{$node->vid}/change-state/{$state}",
      ));
    }
  }

  return $links;
}
