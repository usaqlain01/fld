<?php
// $Id: acquia_search.module 5200 2010-03-04 21:55:23Z buildbot $

/**
 * @file
 *   Integration between Acquia Drupal and Acquia's hosted solr search service.
 */

define('ACQUIA_SEARCH_VERSION', "ACQ_search_version_ACQ");
define('ACQUIA_SEARCH_SERVER_ID', 'acquia_search_server_1');


/**
 * Predefined Acquia Search network server
 */
function acquia_search_get_server() {
  $acquia_server = array(
    'server_id' => ACQUIA_SEARCH_SERVER_ID,
    'name' => t('Acquia Search'),
    'host' => variable_get('acquia_search_host', 'search.acquia.com'),
    'port' => variable_get('acquia_search_port', '80'),
    'path' => variable_get('acquia_search_path', '/solr/'. acquia_agent_settings('acquia_identifier')),
    'service_class' => 'AcquiaSearchService');
  return $acquia_server;
}

/**
 * Implementation of hook_enable().
 */
function acquia_search_enable() {
  if (acquia_agent_subscription_is_active()) {
    acquia_search_lock_acquia_solr_server();
    // Send a heartbeat so the Acquia Network knows the module is enabled.
    acquia_agent_check_subscription();
  }
}

/**
 * Implementation of hook_init().
 */
function acquia_search_init() {
  if (arg(0) == 'admin' && arg(1) == 'config' && arg(2) == 'search' && arg(3) == 'apachesolr'
      && user_access('administer search')
      && acquia_agent_subscription_is_active()
      && variable_get('apachesolr_default_server') == ACQUIA_SEARCH_SERVER_ID
      && empty($_POST)) {
    $as_link = l(t('Acquia Search'), 'http://acquia.com/products-services/acquia-search');
    drupal_set_message(t("Search is being provided by the !as network service.", array('!as' => $as_link)));
  }
}

/**
 * Create a new record pointing to the Acquia apachesolr search server and set it as the default
 */
function acquia_search_lock_acquia_solr_server() {
  apachesolr_server_save(acquia_search_get_server());

  variable_set('apachesolr_default_server', ACQUIA_SEARCH_SERVER_ID);
  if (!variable_get('apachesolr_failure', FALSE)) {
    variable_set('apachesolr_failure', 'show_drupal_results');
  }
}

/**
 * Implementation of hook_disable().
 */
function acquia_search_disable() {
  acquia_search_unlock_acquia_solr_server();
}

/**
 * Helper function to clear variables we may have set.
 */
function acquia_search_unlock_acquia_solr_server() {
  apachesolr_server_delete(ACQUIA_SEARCH_SERVER_ID);
  $servers = apachesolr_load_all_servers();
  if (empty($servers)) {
    apachesolr_server_save(array('server_id' => 'solr', 'name' => 'Apache Solr server', 'host' => 'localhost', 'port' => '8983', 'path' => '/solr'));
    variable_set('apachesolr_default_server', 'solr');
  }
  else {
    variable_set('apachesolr_default_server', key($servers));
  }
}

/**
 * Implementation of hook_menu_alter().
 */
function acquia_search_menu_alter(&$menu) {
  $del_pg = 'admin/config/search/apachesolr/server/%apachesolr_server/delete';
  if (isset($menu[$del_pg])) {
    $menu[$del_pg]['page callback'] = 'apachesolr_server_delete_page';
  };
}

/**
 * Implementation of hook_form_[form_id]_alter().
 */
function acquia_search_form_apachesolr_settings_alter(&$form, $form_state) {
  // Don't alter the form if there is no subscription.
  if (acquia_agent_subscription_is_active()) {
    // Don't show delete operation for the AS server
    foreach ($form['apachesolr_host_settings']['table']['#rows'] as &$row) {
      if (isset($row['data'][2]['data']) && strpos($row['data'][2]['data'], 'apachesolr/server/' . ACQUIA_SEARCH_SERVER_ID . '/delete') !== FALSE) {
        $row['data'][2]['data'] = '';
        break;
      }
    }
  }
}

/**
 * Implementation of hook_form_[form_id]_alter().
 */
function acquia_search_form_apachesolr_server_edit_form_alter(&$form, $form_state) {
  // Do not allow editing of Acquia Search server parameters
  if (isset($form_state['build_info']['args'][0]['server_id']) && $form_state['build_info']['args'][0]['server_id'] == ACQUIA_SEARCH_SERVER_ID ) {
    $form['host']['#disabled'] = TRUE; 
    $form['port']['#disabled'] = TRUE;
    $form['path']['#disabled'] = TRUE;
    $form['name']['#disabled'] = TRUE;
    $form['server_id']['#disabled'] = TRUE;    
  }

  $form['save']['#validate'][] = 'acquia_search_server_edit_form_validate';
}

function acquia_search_server_edit_form_validate($form, &$form_state) {
  if ($form_state['values']['server_id'] == ACQUIA_SEARCH_SERVER_ID) {
    // make sure that the server parameters has not been changed
    $form_state['values'] = array_merge($form_state['values'], acquia_search_get_server());
  }
}

/**
 * Delete server page 
 */
function acquia_search_apachesolr_server_delete_page($server) {
  $is_as = $server['server_id'] == ACQUIA_SEARCH_SERVER_ID;
  if ($is_as) {
    return MENU_ACCESS_DENIED;
  }
  return apachesolr_server_delete_page($server);  
}


/**
 * Implementation of hook_acquia_subscription_status().
 */

function acquia_search_acquia_subscription_status($active) {
  if ($active) {
    acquia_search_lock_acquia_solr_server();
  }
  else {
    acquia_search_unlock_acquia_solr_server();
  }
}

/**
 * Process a block search form submission.
 */
function acquia_search_search_box_form_submit($form, &$form_state) {
  $form_id = $form['form_id']['#value'];
  $keys = $form_state['values'][$form_id];
  // Handle Apache clean URL quirks.
  if (variable_get('clean_url', '0')) {
    $keys = str_replace('+', '%2B', $keys);
  }
  $form_state['redirect'] = 'search/apachesolr_search/'. trim($keys);
}

/**
 * Modify a solr base url and construct a hmac authenticator cookie.
 *
 * @param $url
 *  The solr url beng requested - passed by reference and may be altered.
 * @param $string
 *  A string - the data to be authenticated, or empty to just use the path
 *  and query from the url to build the authenticator.
 * @param $derived_key
 *  Optional string to supply the derived key.
 *
 * @return
 *  An array containing the string to be added as the content of the
 *  Cookie header to the request and the nonce.
 */
function acquia_search_auth_cookie(&$url, $string = '', $derived_key = NULL) {
  $uri = parse_url($url);

  // Add a scheme - should always be https if available.
  if (in_array('ssl', stream_get_transports(), TRUE) && !defined('ACQUIA_DEVELOPMENT_NOSSL')) {
    $scheme = 'https://';
    $port = '';
  }
  else {
    $scheme = 'http://';
    $port = (isset($uri['port']) && $uri['port'] != 80) ? ':'. $uri['port'] : '';
  }
  $path = isset($uri['path']) ? $uri['path'] : '/';
  $query = isset($uri['query']) ? '?'. $uri['query'] : '';
  $url = $scheme . $uri['host'] . $port . $path . $query;

  $nonce = md5(drupal_random_bytes(55));

  if ($string) {
    $auth_header = acquia_search_authenticator($string, $nonce, $derived_key);
  }
  else {
    $auth_header = acquia_search_authenticator($path . $query, $nonce, $derived_key);
  }
  return array($auth_header, $nonce);
}

/**
 * Derive a key for the solr hmac using the information shared with acquia.com.
 */
function _acquia_search_derived_key() {
  static $derived_key;
  if (!isset($derived_key)) {
    $key = acquia_agent_settings('acquia_key');
    $subscription = acquia_agent_settings('acquia_subscription_data');
    $identifier = acquia_agent_settings('acquia_identifier');
    // We use a salt from acquia.com in key derivation since this is a shared
    // value that we could change on the AN side if needed to force any
    // or all clients to use a new derived key.  We also use a string
    // ('solr') specific to the service, since we want each service using a
    // derived key to have a separate one.
    if (empty($subscription['active']) || empty($key) || empty($identifier)) {
      // Expired or invalid subscription - don't continue.
      $derived_key = '';
    }
    else {
      $salt = isset($subscription['derived_key_salt']) ? $subscription['derived_key_salt'] : '';
      $derivation_string = $identifier . 'solr' . $salt;
      $derived_key = _acquia_search_hmac($key, str_pad($derivation_string, 80, $derivation_string));
    }
  }
  return $derived_key;
}

/**
 * Creates an authenticator based on a data string and HMAC-SHA1.
 */
function acquia_search_authenticator($string, $nonce, $derived_key = NULL) {
  if (empty($derived_key)) {
    $derived_key = _acquia_search_derived_key();
  }
  if (empty($derived_key)) {
    // Expired or invalid subscription - don't continue.
    return '';
  }
  else {
    $time = REQUEST_TIME;
    return 'acquia_solr_time='. $time .'; acquia_solr_nonce='. $nonce .'; acquia_solr_hmac='. _acquia_search_hmac($derived_key, $time . $nonce . $string) .';';
  }
}

/**
 * Validate the authenticity of returned data using a nonce and HMAC-SHA1.
 *
 * @return
 *  TRUE or FALSE.
 */
function acquia_search_valid_response($hmac, $nonce, $string, $derived_key = NULL) {
  if (empty($derived_key)) {
    $derived_key = _acquia_search_derived_key();
  }
  return $hmac == _acquia_search_hmac($derived_key, $nonce . $string);
}

/**
 * Look in the headers and get the hmac_digest out
 * @return string hmac_digest
 *
 */
function acquia_search_extract_hmac($http_response_header) {
  $reg = array();
  if (is_array($http_response_header)) {
    foreach ($http_response_header as $header) {
      if (preg_match("/Pragma:.*hmac_digest=(.+);/i", $header, $reg)) {
        return trim($reg[1]);
      }
    }
  }
  return '';
}

/**
 * Calculates a HMAC-SHA1 of a data string.
 *
 * See RFC2104 (http://www.ietf.org/rfc/rfc2104.txt). Note, the result of this
 * must be identical to using hash_hmac('sha1', $string, $key);  We don't use
 * that function since PHP can be missing it if it was compiled with the
 * --disable-hash switch. However, the hash extension is enabled by default
 * as of PHP 5.1.2, so we should consider requiring it and using the built-in
 * function since it is a little faster (~1.5x).
 */
function _acquia_search_hmac($key, $string) {
  return sha1((str_pad($key, 64, chr(0x00)) ^ (str_repeat(chr(0x5c), 64))) . pack("H*", sha1((str_pad($key, 64, chr(0x00)) ^ (str_repeat(chr(0x36), 64))) . $string)));
}

/**
 * Implementation of hook_update_status_alter().
 *
 * This function disables the reporting of apachesolr update notifications
 * if the acquia_search module is enabled.  When the administrator updates
 * the acquia_search module, the apachesolr module is also updated, so there
 * is no need for both.
 *
 * @param $projects
 *   Reference to an array of information about available updates to each
 *   project installed on the system.
 *
 * @see update_calculate_project_data()
 */
function acquia_search_update_status_alter(&$projects) {
  // If we are running Acquia Drupal, acquia_agent handles this.
  if (!acquia_agent_has_update_service() && isset($projects['apachesolr'])) {
    $projects['acquia_search']['includes']['apachesolr'] = $projects['apachesolr']['title'];
    unset($projects['apachesolr']);
  }
}
